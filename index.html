<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Cube Runner</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            z-index: 100;
        }
        #info h2 {
            margin: 0 0 10px 0;
            color: #00ffff;
            font-size: 24px;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        button:active {
            transform: translateY(0);
        }
        #modeToggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            display: none;
            text-align: center;
            z-index: 200;
            border: 3px solid #ff00ff;
        }
        canvas {
            display: block;
        }
        .stat {
            margin: 8px 0;
            font-size: 16px;
        }
        .stat span {
            color: #00ffff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>üéÆ Rhythm Cube Runner</h2>
        <div style="font-size: 12px; color: #888; margin-bottom: 10px;">Group ID: 5559</div>
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Speed: <span id="speed">1.0x</span></div>
        <div class="stat">Combo: <span id="combo">0</span></div>
        <div class="stat">Mode: <span id="mode">Prototype</span></div>
        <div style="margin-top: 15px; font-size: 13px; color: #aaa;">
            ‚Üê ‚Üí or A/D: Move<br>
            Space/Click: Jump<br>
            Mouse: Move left/right<br>
            Collect cubes, avoid obstacles!
        </div>
    </div>
    
    <button id="modeToggle">Switch to Full Mode</button>
    
    <div id="controls">
        <button id="left">‚Üê</button>
        <button id="jump">JUMP</button>
        <button id="right">‚Üí</button>
    </div>

    <div id="gameOver">
        <h1 style="color: #ff00ff; font-size: 48px; margin: 0;">GAME OVER!</h1>
        <p style="font-size: 24px; margin: 20px 0;">Final Score: <span id="finalScore" style="color: #00ffff;">0</span></p>
        <p style="font-size: 18px; color: #888;">Max Combo: <span id="maxCombo" style="color: #ffff00;">0</span></p>
        <button id="restart" style="margin-top: 20px;">Play Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let player;
        let platforms = [];
        let obstacles = [];
        let collectibles = [];
        let particles = [];
        let score = 0;
        let combo = 0;
        let maxCombo = 0;
        let gameSpeed = 0.15;
        let prototypeMode = true;
        let gameRunning = true;
        let isJumping = false;
        let jumpVelocity = 0;
        let playerLane = 0; // -1, 0, 1
        const LANE_WIDTH = 3;
        const GRAVITY = -0.02;
        const JUMP_POWER = 0.35;
        
        const keys = {};
        let lastKeyTime = 0;
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 80);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12);
            camera.lookAt(0, 2, -10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000814);
            document.body.appendChild(renderer.domElement);
            
            setupLighting();
            createPlayer();
            createInitialPlatforms();
            createTunnel();
            
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onMouseClick);
            
            document.getElementById('modeToggle').addEventListener('click', toggleMode);
            document.getElementById('restart').addEventListener('click', restart);
            document.getElementById('left').addEventListener('click', () => movePlayer(-1));
            document.getElementById('right').addEventListener('click', () => movePlayer(1));
            document.getElementById('jump').addEventListener('click', jump);
            
            animate();
        }
        
        function setupLighting() {
            const ambient = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambient);
            
            const front = new THREE.DirectionalLight(0xffffff, 0.8);
            front.position.set(0, 10, 10);
            scene.add(front);
            
            // Colorful point lights for atmosphere
            const colors = [0xff00ff, 0x00ffff, 0xffff00];
            for (let i = 0; i < 3; i++) {
                const light = new THREE.PointLight(colors[i], 1, 30);
                light.position.set((i - 1) * 10, 5, -20 - i * 10);
                scene.add(light);
            }
        }
        
        function createPlayer() {
            if (player) scene.remove(player);
            
            player = new THREE.Group();
            
            if (prototypeMode) {
                const bodyGeom = new THREE.BoxGeometry(1, 1, 1);
                const bodyMat = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x004400
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                player.add(body);
            } else {
                // Main body
                const bodyGeom = new THREE.BoxGeometry(0.8, 1.2, 0.8);
                const bodyMat = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x004400,
                    shininess: 100
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 0.1;
                player.add(body);
                
                // Head
                const headGeom = new THREE.SphereGeometry(0.4, 16, 16);
                const headMat = new THREE.MeshPhongMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x004444
                });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 0.9;
                player.add(head);
                
                // Eyes
                for (let i = 0; i < 2; i++) {
                    const eyeGeom = new THREE.SphereGeometry(0.08, 8, 8);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const eye = new THREE.Mesh(eyeGeom, eyeMat);
                    eye.position.set(i === 0 ? -0.15 : 0.15, 0.95, 0.35);
                    player.add(eye);
                    
                    const pupilGeom = new THREE.SphereGeometry(0.04, 8, 8);
                    const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const pupil = new THREE.Mesh(pupilGeom, pupilMat);
                    pupil.position.set(i === 0 ? -0.15 : 0.15, 0.95, 0.4);
                    player.add(pupil);
                }
                
                // Arms
                for (let i = 0; i < 2; i++) {
                    const armGeom = new THREE.BoxGeometry(0.25, 0.8, 0.25);
                    const armMat = new THREE.MeshPhongMaterial({ color: 0x00dd00 });
                    const arm = new THREE.Mesh(armGeom, armMat);
                    arm.position.set(i === 0 ? -0.65 : 0.65, 0.1, 0);
                    arm.rotation.z = (i === 0 ? 1 : -1) * 0.3;
                    player.add(arm);
                }
                
                // Legs
                for (let i = 0; i < 2; i++) {
                    const legGeom = new THREE.BoxGeometry(0.3, 0.6, 0.3);
                    const legMat = new THREE.MeshPhongMaterial({ color: 0x00cc00 });
                    const leg = new THREE.Mesh(legGeom, legMat);
                    leg.position.set(i === 0 ? -0.25 : 0.25, -0.8, 0);
                    player.add(leg);
                }
            }
            
            player.position.set(0, 2, 0);
            scene.add(player);
        }
        
        function createPlatform(z) {
            const platform = new THREE.Group();
            
            // Create three lanes
            for (let i = -1; i <= 1; i++) {
                const geom = new THREE.BoxGeometry(2.5, 0.5, 10);
                const mat = new THREE.MeshPhongMaterial({ 
                    color: prototypeMode ? 0x444444 : 0x2a2a5a,
                    emissive: prototypeMode ? 0x000000 : 0x1a1a3a
                });
                const segment = new THREE.Mesh(geom, mat);
                segment.position.set(i * LANE_WIDTH, 0, 0);
                segment.receiveShadow = true;
                platform.add(segment);
            }
            
            platform.position.z = z;
            scene.add(platform);
            platforms.push(platform);
            
            // Randomly spawn obstacles or collectibles
            if (Math.random() < 0.4) {
                spawnObstacle(z);
            } else if (Math.random() < 0.6) {
                spawnCollectible(z);
            }
        }
        
        function spawnObstacle(z) {
            const lane = Math.floor(Math.random() * 3) - 1;
            const obstacle = new THREE.Group();
            
            if (prototypeMode) {
                const geom = new THREE.BoxGeometry(1.5, 2, 1.5);
                const mat = new THREE.MeshPhongMaterial({ 
                    color: 0xff0000,
                    emissive: 0x440000
                });
                const mesh = new THREE.Mesh(geom, mat);
                obstacle.add(mesh);
            } else {
                // Spike obstacle
                const baseGeom = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 8);
                const baseMat = new THREE.MeshPhongMaterial({ color: 0x660000 });
                const base = new THREE.Mesh(baseGeom, baseMat);
                base.position.y = 0.25;
                obstacle.add(base);
                
                for (let i = 0; i < 6; i++) {
                    const spikeGeom = new THREE.ConeGeometry(0.3, 1.5, 8);
                    const spikeMat = new THREE.MeshPhongMaterial({ 
                        color: 0xff0000,
                        emissive: 0x440000
                    });
                    const spike = new THREE.Mesh(spikeGeom, spikeMat);
                    const angle = (i / 6) * Math.PI * 2;
                    spike.position.set(Math.cos(angle) * 0.5, 1.3, Math.sin(angle) * 0.5);
                    obstacle.add(spike);
                }
            }
            
            obstacle.position.set(lane * LANE_WIDTH, 1.5, z);
            obstacle.userData.lane = lane;
            obstacle.userData.type = 'obstacle';
            scene.add(obstacle);
            obstacles.push(obstacle);
        }
        
        function spawnCollectible(z) {
            const lane = Math.floor(Math.random() * 3) - 1;
            const collectible = new THREE.Group();
            
            if (prototypeMode) {
                const geom = new THREE.SphereGeometry(0.5, 8, 8);
                const mat = new THREE.MeshPhongMaterial({ 
                    color: 0xffff00,
                    emissive: 0x888800
                });
                const mesh = new THREE.Mesh(geom, mat);
                collectible.add(mesh);
            } else {
                // Crystal collectible
                const geom = new THREE.OctahedronGeometry(0.5, 0);
                const mat = new THREE.MeshPhongMaterial({ 
                    color: 0xffff00,
                    emissive: 0x888800,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                const crystal = new THREE.Mesh(geom, mat);
                collectible.add(crystal);
                
                // Glow ring
                const ringGeom = new THREE.TorusGeometry(0.7, 0.05, 8, 16);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.5
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2;
                collectible.add(ring);
            }
            
            collectible.position.set(lane * LANE_WIDTH, 2, z);
            collectible.userData.lane = lane;
            collectible.userData.type = 'collectible';
            scene.add(collectible);
            collectibles.push(collectible);
        }
        
        function createInitialPlatforms() {
            for (let i = 0; i < 15; i++) {
                createPlatform(-10 - i * 10);
            }
        }
        
        function createTunnel() {
            // Create side walls
            for (let i = 0; i < 20; i++) {
                for (let side = -1; side <= 1; side += 2) {
                    const geom = new THREE.BoxGeometry(1, 8, 10);
                    const mat = new THREE.MeshPhongMaterial({ 
                        color: prototypeMode ? 0x222222 : 0x1a1a3a,
                        emissive: prototypeMode ? 0x000000 : 0x0a0a1a,
                        transparent: true,
                        opacity: 0.3
                    });
                    const wall = new THREE.Mesh(geom, mat);
                    wall.position.set(side * 6, 4, -10 - i * 10);
                    scene.add(wall);
                }
            }
        }
        
        function movePlayer(direction) {
            const now = Date.now();
            if (now - lastKeyTime < 150) return; // Debounce
            lastKeyTime = now;
            
            if (!gameRunning) return;
            
            playerLane = Math.max(-1, Math.min(1, playerLane + direction));
        }
        
        function jump() {
            if (!gameRunning || isJumping) return;
            isJumping = true;
            jumpVelocity = JUMP_POWER;
        }
        
        function updateGame() {
            if (!gameRunning) return;
            
            // Move player to target lane
            const targetX = playerLane * LANE_WIDTH;
            player.position.x += (targetX - player.position.x) * 0.15;
            
            // Jump physics
            if (isJumping) {
                player.position.y += jumpVelocity;
                jumpVelocity += GRAVITY;
                
                if (player.position.y <= 2) {
                    player.position.y = 2;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }
            
            // Player animation
            if (!prototypeMode) {
                player.rotation.y = Math.sin(Date.now() * 0.005) * 0.1;
            }
            
            // Move world
            platforms.forEach((platform, idx) => {
                platform.position.z += gameSpeed;
                if (platform.position.z > 20) {
                    scene.remove(platform);
                    platforms.splice(idx, 1);
                    createPlatform(-140);
                }
            });
            
            // Move and check obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += gameSpeed;
                obstacle.rotation.y += 0.05;
                
                // Check collision
                const dist = Math.abs(obstacle.position.z - player.position.z);
                if (dist < 1.5 && obstacle.userData.lane === playerLane && !isJumping) {
                    gameOver();
                }
                
                if (obstacle.position.z > 10) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }
            
            // Move and check collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.position.z += gameSpeed;
                collectible.rotation.y += 0.1;
                
                if (!prototypeMode) {
                    collectible.position.y = 2 + Math.sin(Date.now() * 0.005 + i) * 0.3;
                }
                
                // Check collection
                const dist = Math.abs(collectible.position.z - player.position.z);
                if (dist < 1.5 && collectible.userData.lane === playerLane) {
                    score += 10 + combo;
                    combo++;
                    maxCombo = Math.max(maxCombo, combo);
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                    createParticleExplosion(collectible.position);
                    
                    // Increase speed gradually
                    gameSpeed = Math.min(0.35, 0.15 + score * 0.0001);
                }
                
                if (collectible.position.z > 10) {
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                    combo = 0; // Missed collectible, reset combo
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life--;
                p.position.add(p.velocity);
                p.scale.multiplyScalar(0.95);
                p.material.opacity -= 0.02;
                
                if (p.life <= 0 || p.material.opacity <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
            
            updateUI();
        }
        
        function createParticleExplosion(position) {
            for (let i = 0; i < 15; i++) {
                const geom = new THREE.SphereGeometry(0.1, 4, 4);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: Math.random() > 0.5 ? 0xffff00 : 0x00ffff,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geom, mat);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    Math.random() * 0.2 - 0.1,
                    Math.random() * 0.2,
                    Math.random() * 0.2 - 0.1
                );
                particle.life = 50;
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('speed').textContent = (gameSpeed / 0.15).toFixed(1) + 'x';
            document.getElementById('combo').textContent = combo;
        }
        
        function toggleMode() {
            prototypeMode = !prototypeMode;
            document.getElementById('mode').textContent = prototypeMode ? 'Prototype' : 'Full';
            document.getElementById('modeToggle').textContent = prototypeMode ? 
                'Switch to Full Mode' : 'Switch to Prototype Mode';
            
            // Recreate player
            createPlayer();
            player.position.y = 2;
            
            // Update existing objects
            platforms.forEach(p => scene.remove(p));
            obstacles.forEach(o => scene.remove(o));
            collectibles.forEach(c => scene.remove(c));
            
            const obstacleData = obstacles.map(o => ({ z: o.position.z, lane: o.userData.lane }));
            const collectibleData = collectibles.map(c => ({ z: c.position.z, lane: c.userData.lane }));
            
            platforms = [];
            obstacles = [];
            collectibles = [];
            
            createInitialPlatforms();
            
            obstacleData.forEach(data => {
                if (data.z > -140 && data.z < 10) {
                    spawnObstacle(data.z);
                }
            });
            
            collectibleData.forEach(data => {
                if (data.z > -140 && data.z < 10) {
                    spawnCollectible(data.z);
                }
            });
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('maxCombo').textContent = maxCombo;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restart() {
            // Clear everything
            platforms.forEach(p => scene.remove(p));
            obstacles.forEach(o => scene.remove(o));
            collectibles.forEach(c => scene.remove(c));
            particles.forEach(p => scene.remove(p));
            
            platforms = [];
            obstacles = [];
            collectibles = [];
            particles = [];
            
            score = 0;
            combo = 0;
            maxCombo = 0;
            gameSpeed = 0.15;
            playerLane = 0;
            isJumping = false;
            jumpVelocity = 0;
            gameRunning = true;
            
            createPlayer();
            createInitialPlatforms();
            updateUI();
            
            document.getElementById('gameOver').style.display = 'none';
        }
        
        function onKeyDown(event) {
            keys[event.key] = true;
            
            if (event.key === 'ArrowLeft' || event.key === 'a' || event.key === 'A') {
                movePlayer(-1);
            }
            if (event.key === 'ArrowRight' || event.key === 'd' || event.key === 'D') {
                movePlayer(1);
            }
            if (event.key === ' ') {
                event.preventDefault();
                jump();
            }
        }
        
        function onKeyUp(event) {
            keys[event.key] = false;
        }
        
        function onMouseMove(event) {
            if (!gameRunning) return;
            
            // Map mouse X position to lanes
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            
            if (mouseX < -0.33) {
                playerLane = -1;
            } else if (mouseX > 0.33) {
                playerLane = 1;
            } else {
                playerLane = 0;
            }
        }
        
        function onMouseClick(event) {
            // Ignore clicks on UI buttons
            if (event.target.tagName === 'BUTTON') return;
            jump();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updateGame();
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>